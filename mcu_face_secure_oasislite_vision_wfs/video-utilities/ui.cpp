/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.38                          *
*        Compiled Nov 24 2016, 16:57:40                              *
*        (c) 2016 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*
* Copyright 2019 NXP.
* This software is owned or controlled by NXP and may only be used strictly in accordance with the
* license terms that accompany it. By expressly accepting such terms or by downloading, installing,
* activating and/or otherwise using the software, you are agreeing that you have read, and that you
* agree to comply with and are bound by, such license terms. If you do not agree to be bound by the
* applicable license terms, then you may not retain, install, activate or otherwise use the software
*
* Created by: NXP China Solution Team.
*/

#if 0

#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "timers.h"
#include "semphr.h"
#include "event_groups.h"
#include <stdio.h>
#include <string>
#include <vector>

#include "oasis.h"
#include "commondef.h"
#include "util.h"
#include "fsl_log.h"
#include "ui.h"
#include "DIALOG.h"
#include "camera.h"
//#include "nxplogo_112.h"

static QueueHandle_t UIMsgQ = NULL;
static QMsg gDisplayReqMsg;

SDK_ALIGN(static uint16_t s_FrameBuffer[APP_CAMERA_WIDTH * APP_CAMERA_HEIGHT], FRAME_BUFFER_ALIGN);

#define LCD_BITS_PER_PIXEL 16
#define UI_BITMAP_FORMAT GUI_DRAW_BMP565

#define ID_MAIN_WINDOW  (GUI_ID_USER + 0x00)
#define ID_BUTTON_LOCK  (GUI_ID_USER + 0x01)
#define ID_BUTTON_MENU  (GUI_ID_USER + 0x02)
#define ID_IMAGE_CAMERA  (GUI_ID_USER + 0x03)


static WM_HWIN gHWin;
static GUI_BITMAP bitmap;
//static GUI_BITMAP bitmapface;
static const GUI_WIDGET_CREATE_INFO mainWindow[] = {
	{ WINDOW_CreateIndirect, "Window", ID_MAIN_WINDOW, 0, 0, 240, 320, 0, 0x0, 0 },
	{ BUTTON_CreateIndirect, "Lock", ID_BUTTON_LOCK, 0, 286, 100, 32, 0, 0x0, 0 },
	{ BUTTON_CreateIndirect, "Menu", ID_BUTTON_MENU, 141, 286, 100, 32, 0, 0x0, 0 },
	{ IMAGE_CreateIndirect, "Image", ID_IMAGE_CAMERA, 0, 0, 240, 280, 0, 0, 0 },
	// USER START (Optionally insert additional widgets)
	// USER END
};


void UI_RefreshNames(void)
{
#if 0
    //WM_HWIN hItem;
    //char name[30] = {0};
    std::vector<std::string> names;
    names.clear();
    //Oasis_GetFaces(names);
    //hItem = WM_GetDialogItem(gHWin, ID_LISTBOX_0);

    //for (unsigned int i = 0; i < names.size(); i++) {
        //LOGD("[%d]:[%s]\r\n", i, names[i].c_str());
        //LISTBOX_DeleteItem(hItem, i);
        //LISTBOX_AddString(hItem, names[i].c_str());
    //}
#endif
}

void UI_DelSelName(void)
{
    //WM_HWIN hItem;
    //char name[30] = {0};
    //hItem = WM_GetDialogItem(gHWin, ID_LISTBOX_0);

    //int index = LISTBOX_GetSel(hItem);
    //LOGD("[DlSel]:%d\r\n", index);

    //if (index >= 0) {
        //LISTBOX_GetItemText(hItem, index, name, 29);
        //LISTBOX_DeleteItem(hItem, index);
        //Oasis_DelFace(name);
    //}
}


static void UI_Callback(WM_MESSAGE* pMsg)
{
    WM_HWIN hItem;
    int     NCode;
    int     Id;
    // USER START (Optionally insert additional variables)
    // USER END

    switch (pMsg->MsgId) {
    case WM_INIT_DIALOG: {
        //
        // Initialization of 'Window'
        //
        hItem = pMsg->hWin;
        WINDOW_SetBkColor(hItem, GUI_MAKE_COLOR(0x00000000));
        //
        // Initialization of 'Lock'
        //
        hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_LOCK);
        BUTTON_SetText(hItem, "Lock");
        BUTTON_SetSkinClassic(hItem);
        BUTTON_SetBkColor(hItem, BUTTON_CI_UNPRESSED, GUI_BLUE);
        BUTTON_SetTextColor(hItem, BUTTON_CI_UNPRESSED, GUI_WHITE);
        //
        // Initialization of 'Menu'
        //
        hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_MENU);
        BUTTON_SetText(hItem, "Menu");
        BUTTON_SetSkinClassic(hItem);
        BUTTON_SetBkColor(hItem, BUTTON_CI_UNPRESSED, GUI_RED);
        BUTTON_SetTextColor(hItem, BUTTON_CI_UNPRESSED, GUI_WHITE);
        // USER START (Optionally insert additional code for further widget initialization)
        // USER END
    }
    break;

    case WM_NOTIFY_PARENT: {
        Id    = WM_GetId(pMsg->hWinSrc);
        NCode = pMsg->Data.v;

        switch (Id) {
		case ID_BUTTON_LOCK: // Notifications sent by 'Lock'
			switch (NCode) {
			case WM_NOTIFICATION_CLICKED:
			// USER START (Optionally insert code for reacting on notification message)
			// USER END
			break;
			case WM_NOTIFICATION_RELEASED:
			// USER START (Optionally insert code for reacting on notification message)
			// USER END
			break;
			// USER START (Optionally insert additional code for further notification handling)
			// USER END
			}
			break;

		case ID_BUTTON_MENU: // Notifications sent by 'Menu'
			switch(NCode) {
			case WM_NOTIFICATION_CLICKED:
			// USER START (Optionally insert code for reacting on notification message)
			// USER END
			break;
			case WM_NOTIFICATION_RELEASED:
			// USER START (Optionally insert code for reacting on notification message)
			// USER END
			break;
			// USER START (Optionally insert additional code for further notification handling)
			// USER END
			}
			break;
			// USER START (Optionally insert additional code for further Ids)
			// USER END
        }
	}
    break;
  // USER START (Optionally insert additional message handling)
  // USER END
	default: {
		WM_DefaultProc(pMsg);
	}
	break;

    }
}

void UI_UpdateFrame(void)
{
#if 1
    WM_HWIN hItem;
    bitmap.XSize = REC_RECT_WIDTH;
    bitmap.YSize = REC_RECT_HEIGHT-40;
    bitmap.BitsPerPixel = LCD_BITS_PER_PIXEL;
    bitmap.BytesPerLine = REC_RECT_WIDTH * 2 * 2;
    bitmap.pData = (unsigned char*)s_FrameBuffer;
    bitmap.pPal = NULL;
    bitmap.pMethods = UI_BITMAP_FORMAT;
    hItem = WM_GetDialogItem(gHWin, ID_IMAGE_CAMERA);
    WM_EnableMemdev(hItem);
    IMAGE_SetBitmap(hItem, &bitmap);
#endif
//    GUI_CreateBitmapFromStream();
//    GUI_DrawStreamedBitmap565Ex();
}

void UI_UpdateFace(unsigned char* pFace)
{
#if 0
    WM_HWIN hItem;
    bitmapface.XSize = SNAPSHOT_WIDTH;
    bitmapface.YSize = SNAPSHOT_HEIGHT;
    bitmapface.BitsPerPixel = LCD_BITS_PER_PIXEL;
    bitmapface.BytesPerLine = SNAPSHOT_WIDTH * 4;
    bitmapface.pData = pFace;
    bitmapface.pPal = NULL;
    bitmapface.pMethods = UI_BITMAP_FORMAT;
    hItem = WM_GetDialogItem(gHWin, ID_IMAGE_1);
    IMAGE_SetBitmap(hItem, &bitmapface);
#endif
}

void UI_ShowFoundName(const char* name, float similar)
{
#if 0
    WM_HWIN hItem;
    GUI_COLOR color = GUI_MAKE_COLOR(0x00FF0000); // blue

    if (similar >= THRESHOLD_PASS) {
        char str[7] = {0};
        float f_confidence = similar * 100;
        sprintf(str, "%d.%d%%", (int)f_confidence, (int)((f_confidence - (int)f_confidence) * 100));
        hItem = WM_GetDialogItem(gHWin, ID_EDIT_0);//similar
        EDIT_SetText(hItem, str);
    } else {
        color = GUI_MAKE_COLOR(0x000000FF); // red
    }

    hItem = WM_GetDialogItem(gHWin, ID_EDIT_1);//name
    EDIT_SetText(hItem, name);
    hItem = WM_GetDialogItem(gHWin, ID_TEXT_3);
    TEXT_SetText(hItem, name);
    hItem = WM_GetDialogItem(gHWin, ID_TEXT_0); //confidence:
    TEXT_SetTextColor(hItem, color);
#endif
}

void UI_ResetDialog(void)
{
#if 0
    WM_HWIN hItem;
    //
    // Initialization of 'Confidence'
    //
    hItem = WM_GetDialogItem(gHWin, ID_TEXT_0);
    TEXT_SetText(hItem, "Confidence:");
    TEXT_SetTextColor(hItem, GUI_MAKE_COLOR(0x000000FF));
    //
    // Initialization of 'similarity'
    //
    hItem = WM_GetDialogItem(gHWin, ID_EDIT_0);
    EDIT_SetText(hItem, "");
    //
    // Initialization of 'foundName'
    //
    hItem = WM_GetDialogItem(gHWin, ID_EDIT_1);
    EDIT_SetText(hItem, "");
    hItem = WM_GetDialogItem(gHWin, ID_TEXT_3);
    TEXT_SetText(hItem, "");
    // USER START (Optionally insert additional code for further widget initialization)
    hItem = WM_GetDialogItem(gHWin, ID_IMAGE_1);
    IMAGE_SetBitmap(hItem, &bmLogo);
    // USER END
#endif
}

void UI_DelExistName(const char* oldName)
{
#if 0
    WM_HWIN hItem;
    char temp[30] = {0};
    hItem = WM_GetDialogItem(gHWin, ID_LISTBOX_0);
    LOGD("[UIDEL]:%s\r\n", oldName);
    unsigned int numItems = LISTBOX_GetNumItems(hItem);

    for (unsigned int i = 0; i < numItems; i++) {
        LISTBOX_GetItemText(hItem, i, temp, 29);

        if (strcmp(temp, oldName) == 0) {
            LISTBOX_DeleteItem(hItem, i);
            break;
        }
    }
#endif
}

void UI_AddName(const char* newName)
{
    //WM_HWIN hItem;
    //hItem = WM_GetDialogItem(gHWin, ID_LISTBOX_0);
    //LISTBOX_AddString(hItem, newName);
    LOGD("[UIADD]:%s\r\n", newName);
}

void UI_Task(void* param)
{
    BaseType_t ret;
    QMsg* pQMsg;
    /* emWin start */
    GUI_Init();
    WM_MULTIBUF_Enable(1);
    gHWin = GUI_CreateDialogBox(mainWindow, GUI_COUNTOF(mainWindow), UI_Callback, WM_HBKWIN, 0, 0);
    WM_Exec();

    pQMsg = &gDisplayReqMsg;
    gDisplayReqMsg.msg.raw.data = (void*)s_FrameBuffer;
    Camera_SendQMsg((void*)&pQMsg);

    while (1) {
        ret = xQueueReceive(UIMsgQ, (void*)&pQMsg, portMAX_DELAY);
        if (ret == pdTRUE) {
            switch (pQMsg->id) {
                case QMSG_DISPLAY_FRAME_RES: {
                        UI_UpdateFrame();
                        GUI_Exec();
                        vTaskDelay(pdMS_TO_TICKS(100));

                        pQMsg = &gDisplayReqMsg;
                        gDisplayReqMsg.msg.raw.data = (void*)s_FrameBuffer;
                        Camera_SendQMsg((void*)&pQMsg);
                }
                break;
                case QMSG_SWITCH_1: {
                     uint8_t key = *(uint8_t*)pQMsg->msg.raw.data;
                     GUI_Exec();
                }
                break;
             default:
                break;
            }
        }
    }
}

void UI_Start(void)
{
    gDisplayReqMsg.id = QMSG_DISPLAY_FRAME_REQ;
    gDisplayReqMsg.msg.raw.data = (void*)s_FrameBuffer;
    UIMsgQ = xQueueCreate(UI_MSG_Q_COUNT, sizeof(QMsg*));
    if (UIMsgQ == NULL) {
        LOGE("[ERROR]:xQueueCreate facedet queue\r\n");
        return;
    }

    if (xTaskCreate(UI_Task, "UI Task", UITASK_STACKSIZE,
                    NULL, UITASK_PRIORITY, NULL) != pdPASS) {
        LOGE("[ERROR]UI Task created failed\r\n");

        while (1);
    }
}

int UI_SendQMsg(void* msg)
{
    BaseType_t ret;

    ret = xQueueSend(UIMsgQ, msg, (TickType_t)0);

    if (ret != pdPASS)
    {
        LOGE("[ERROR]:UI_SendQMsg failed %d\r\n", ret);
        return -1;
    }

    return 0;
}

#endif
